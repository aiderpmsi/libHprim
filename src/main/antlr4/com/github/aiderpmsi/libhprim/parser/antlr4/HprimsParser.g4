parser grammar HprimsParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = HprimsLexer;
    
    superClass = AbstractHprimsParser;
    
}

@header {
import com.github.aiderpmsi.libhprim.parser.AbstractHprimsParser;
import java.util.HashMap;
}

hprim
@init{startDocument();}
@after{endDocument();} :
  line_h
  CR* CRNONPRINTABLE* EOF;

// line h (same for all versions)
line_h:
   a=HCONTENT {startElement("H.1");content($a.text);endElement();}
   b=HDELIMITER1 c=HDELIMITER2 d=HREPETITER e=HESC f=HDELIMITER3 {startElement("H.2");content($b.text + $c.text + $d.text + $e.text + $f.text);endElement();}
   DELIMITER1 g=content {matchRegex($g.contentText, "^.{0,12}$");} {startElement("H.3");content($g.contentText);endElement();}
   DELIMITER1 h=content {matchRegex($h.contentText, "^.{0,12}$");} {startElement("H.4");content($h.contentText);endElement();}
   DELIMITER1 lvl1_fields["H.5", h_5, 2, "^.{0,40}$"]
   DELIMITER1 j=content {matchRegex($j.contentText, "^.{0,12}$");} {startElement("H.6");content($j.contentText);endElement();}
   DELIMITER1 k=content {matchRegex($k.contentText, "^.{0,12}$");} {startElement("H.7");content($k.contentText);endElement();}
   {tryRegex($k.contentText, "^(?:ADM)|(?:ORU)$")}?
   DELIMITER1 l=content {matchRegex($l.contentText, "^.{0,12}$");} {startElement("H.8");content($l.contentText);endElement();}
   DELIMITER1 m=content {matchRegex($m.contentText, "^.{0,12}$");} {startElement("H.9");content($m.contentText);endElement();}
   DELIMITER1 n=content {matchRegex($n.contentText, "^.{0,12}$");} {startElement("H.10");content($n.contentText);endElement();}
   DELIMITER1 o=content {matchRegex($o.contentText, "^.{0,12}$");} {startElement("H.11");content($o.contentText);endElement();}
   DELIMITER1 p=content {matchRegex($p.contentText, "^.{0,12}$");} {startElement("H.12");content($p.contentText);endElement();}
   DELIMITER1 q=content {matchRegex($q.contentText, "^.{0,12}$");} {startElement("H.13");content($q.contentText);endElement();}
   {tryRegex($q.contentText, "^H2\\.[0-2]$")}?
   CR+ CRNONPRINTABLE*
   ( {$k.contentText.equals("ADM")}?
       ({$q.contentText.equals("H2.0")}? body_adm_2_0
        |
        {$q.contentText.equals("H2.1")}? body_adm_2_1
        |
        {$q.contentText.equals("H2.2")}? body_adm_2_2)
   | {$k.contentText.equals("ORU")}?
       ({$q.contentText.equals("H2.0")}? body_oru_2_0
        |
        {$q.contentText.equals("H2.1")}? body_oru_2_1
        |
        {$q.contentText.equals("H2.2")}? body_oru_2_2)
   );

// Line P (patient)
line_p:
  LINE_P CRDELIMITER1 content;

// Line OBR (Result)
line_obr:
  LINE_OBR CRDELIMITER1 content;


// Types de corps
body_adm_2_0:
  ;

body_adm_2_1:
  ;

body_adm_2_2:
  ;

body_oru_2_0:
  ;

body_oru_2_1:
  line_obr*;

body_oru_2_2:
  ;

// Répétitions de champs sans niveaux
repet_nolevel[String nameElement]
locals[int nb = 1]:
  content[$nameElement + "." + $nb] {$nb++;}
  (REPETITEUR content[$nameElement + "." + $nb] {$nb++;})*;

// Répétitions de champs avec un seul niveau
repet_level1[String nameElement]
locals[int nb = 1]:
  level1[$nameElement + "." + $nb] {$nb++;}
  (REPETITEUR level1[$nameElement + "." + $nb] {$nb++;})*;

// Champs avec un seul niveau
level1[String nameElement]
locals[int nb = 1]:
  content[$nameElement + "." + $nb] {$nb++;}
  (DELIMITER2 content[$nameElement + "." + $b] {$nb++;})*

dirty_champ[String nameElement]
@init{startElement($nameElement);}
@after{endElement();}:
  (field[true] |
   (dirty_sous_champ[$nameElement + ".1"]
    dirty_champ_ordered[$nameElement, 2])
  )?;

// Types de base pour les contenus
content[String nameElement] returns [String contentText]
@init{startElement($nameElement);}
@after{endElement();}:
  g=baseContent {$contentText = ($g.text == null ? "" : $g.text);}
  (CR+ CRNONPRINTABLE* LINE_A CRDELIMITER1 h=baseContent {$contentText += ($h.text == null ? "" : $h.text);})*
  {content($contentText);};

// Contenu de base
baseContent :
  CONTENT?;